{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport CalculateOptions from './CalculateOptions';\nimport IsSolutionCorrect from './IsSolutionCorrect';\nimport CheckConstraints from './CheckConstraints';\nimport { clone_deep } from '../common/helper_functions';\nvar isSolCorrect = new IsSolutionCorrect();\nvar constraints_met = new CheckConstraints();\n\nvar BruteSolve = /*#__PURE__*/function () {\n  function BruteSolve() {\n    _classCallCheck(this, BruteSolve);\n\n    this.iterations = 0;\n    this.maxIterations = 100000;\n  }\n\n  _createClass(BruteSolve, [{\n    key: \"solve\",\n    value: function solve(grid) {\n      this.iterations = 0;\n      var iterativelyFilledGrid = this.iterativeFill(grid);\n\n      if (iterativelyFilledGrid) {\n        return {\n          grid: iterativelyFilledGrid\n        };\n      } else {\n        return {\n          grid: grid\n        };\n      }\n    } // DEPRECIATED METHOD. Left here for comparison\n\n  }, {\n    key: \"recursivelyFillGrid\",\n    value: function recursivelyFillGrid(grid) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0],\n          _ref2 = _slicedToArray(_ref, 2),\n          row = _ref2[0],\n          col = _ref2[1];\n\n      this.iterations++;\n\n      if (this.iterations > this.maxIterations) {\n        console.table(grid);\n        console.log(\"iterations: \".concat(this.iterations));\n        throw new Error('Unsolvable');\n      }\n\n      var options = CalculateOptions(grid);\n      var optionsForElement = options[row * 9 + col];\n      if (options.filter(function (x) {\n        return x.length !== 0;\n      }).length + grid.flat().filter(function (x) {\n        return x.length !== 0;\n      }).length < 81) return false;\n\n      if (row === 8 && col === 8) {\n        if (grid[row][col] === \"\") grid[row][col] = options[row * 9 + col];\n        console.log(\"Completed in : \".concat(this.iterations, \" iterations.\"));\n        if (isSolCorrect.checkGrid(grid)) return grid;else return false;\n      } //next coordinate if the current one is filled. Branch out of possible options if unfilled.\n\n\n      if (optionsForElement.length === 0) {\n        if (grid[row][col] === \"\") return false;\n        var returnedVal = this.recursivelyFillGrid(grid, this.nextCoordinate(row, col));\n        if (returnedVal) return returnedVal;\n      } else {\n        var _iterator = _createForOfIteratorHelper(optionsForElement),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var option = _step.value;\n            // console.log(`trying ${option} of ${optionsForElement} at : [${[row, col]}]`)\n            var newGrid = clone_deep(grid);\n            newGrid[row][col] = option;\n\n            var _returnedVal = this.recursivelyFillGrid(newGrid, this.nextCoordinate(row, col));\n\n            if (_returnedVal) return _returnedVal; // console.log(`branch ${option} of ${optionsForElement} at : [${[row, col]}] failed`)\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"iterativeFill\",\n    value: function iterativeFill(orig_grid) {\n      var grid = _toConsumableArray(orig_grid);\n\n      var i = 0;\n\n      while (i >= 0 && i < 81) {\n        this.iterations++;\n\n        if (this.iterations > this.maxIterations) {\n          console.table(grid);\n          console.log(\"Max iterations hit: \".concat(this.iterations));\n          return null; // throw new Error('Unsolvable. Iteration limit hit.');\n        }\n\n        if (orig_grid[i] !== \"\") {\n          i++;\n        }\n\n        if (grid[i] === \"\") {\n          grid[i] = 1;\n        }\n\n        if (grid[i] > 9) {\n          grid[i] = \"\";\n          i--;\n\n          while (i >= 0 && orig_grid[i] !== \"\") {\n            i--;\n          }\n\n          if (i < 0) {\n            // unsolvable\n            // console.log(grid);\n            console.log(\"Unsolvable. Iterations: \".concat(this.iterations));\n            return null;\n          }\n\n          grid[i]++;\n        }\n\n        if (constraints_met.element(grid, i) && grid[i] <= 9) {\n          i++;\n\n          while (i < 81 && orig_grid[i] !== \"\") {\n            i++;\n          }\n        } else {\n          grid[i]++;\n        }\n      }\n\n      console.log(\"Iterations for solution: \".concat(this.iterations));\n      return grid;\n    }\n  }, {\n    key: \"nextCoordinate\",\n    value: function nextCoordinate(row, col) {\n      if (col < 8) {\n        col++;\n      } else {\n        row++;\n        col = 0;\n      }\n\n      return [row, col];\n    }\n  }, {\n    key: \"prevCoordinate\",\n    value: function prevCoordinate(row, col) {\n      if (col > 0) {\n        col--;\n      } else {\n        row--;\n        col = 8;\n      }\n\n      return [row, col];\n    } // update grid //copied from solver.js. Needs consolidation later.\n\n  }, {\n    key: \"updateGrid\",\n    value: function updateGrid(grid, updates) {\n      for (var itemIndex in updates) {\n        var rowIndex = Math.floor(itemIndex / 9);\n        var colIndex = itemIndex - rowIndex * 9;\n        console.log(\"Changing \".concat(rowIndex, \":\").concat(colIndex, \",(\").concat(itemIndex, \")   :  \").concat(updates[itemIndex]));\n        grid[rowIndex][colIndex] = updates[itemIndex];\n      }\n\n      return grid;\n    }\n  }]);\n\n  return BruteSolve;\n}();\n\nexport default BruteSolve;","map":{"version":3,"sources":["C:/Users/alons/OneDrive/Documentos/Todos los proyectos descargados/react-sudoku-master/src/components/BruteSolver.js"],"names":["CalculateOptions","IsSolutionCorrect","CheckConstraints","clone_deep","isSolCorrect","constraints_met","BruteSolve","iterations","maxIterations","grid","iterativelyFilledGrid","iterativeFill","row","col","console","table","log","Error","options","optionsForElement","filter","x","length","flat","checkGrid","returnedVal","recursivelyFillGrid","nextCoordinate","option","newGrid","orig_grid","i","element","updates","itemIndex","rowIndex","Math","floor","colIndex"],"mappings":"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","sourcesContent":["import CalculateOptions from './CalculateOptions';\nimport IsSolutionCorrect from './IsSolutionCorrect';\nimport CheckConstraints from './CheckConstraints';\nimport { clone_deep } from '../common/helper_functions';\n\nconst isSolCorrect = new IsSolutionCorrect();\nconst constraints_met = new CheckConstraints();\n\nclass BruteSolve {\n  constructor() {\n    this.iterations = 0;\n    this.maxIterations = 100000;\n  }\n\n  solve(grid) {\n    this.iterations = 0;\n    let iterativelyFilledGrid = this.iterativeFill(grid);\n    if (iterativelyFilledGrid) {\n      return {\n        grid: iterativelyFilledGrid\n      };\n    } else {\n      return {\n        grid: grid\n      };\n    }\n  }\n\n  // DEPRECIATED METHOD. Left here for comparison\n  recursivelyFillGrid(grid, [row, col] = [0, 0]) {\n\n    this.iterations++;\n\n    if (this.iterations > this.maxIterations) {\n      console.table(grid);\n      console.log(`iterations: ${this.iterations}`)\n      throw new Error('Unsolvable');\n    }\n\n    let options = CalculateOptions(grid);\n    let optionsForElement = options[row * 9 + col];\n\n    if (options.filter((x) => x.length !== 0).length + grid.flat().filter((x) => x.length !== 0).length < 81) return false;\n\n    if (row === 8 && col === 8) {\n      if (grid[row][col] === \"\") grid[row][col] = options[row * 9 + col];\n      console.log(`Completed in : ${this.iterations} iterations.`);\n      if (isSolCorrect.checkGrid(grid)) return grid;\n      else return false\n    }\n\n    //next coordinate if the current one is filled. Branch out of possible options if unfilled.\n    if (optionsForElement.length === 0) {\n\n      if (grid[row][col] === \"\") return false;\n      let returnedVal = this.recursivelyFillGrid(grid, this.nextCoordinate(row, col));\n      if (returnedVal) return returnedVal;\n\n    } else {\n      for (let option of optionsForElement) {\n\n        // console.log(`trying ${option} of ${optionsForElement} at : [${[row, col]}]`)\n\n        let newGrid = clone_deep(grid);\n        newGrid[row][col] = option;\n\n        let returnedVal = this.recursivelyFillGrid(newGrid, this.nextCoordinate(row, col));\n        if (returnedVal) return returnedVal;\n\n        // console.log(`branch ${option} of ${optionsForElement} at : [${[row, col]}] failed`)\n\n      }\n    }\n\n    return false;\n  }\n\n  iterativeFill(orig_grid) {\n    let grid = [...orig_grid]\n\n    let i = 0\n    \n    while ( i >= 0 && i < 81) {\n      \n      this.iterations++;\n\n      if (this.iterations > this.maxIterations) {\n        console.table(grid);\n        console.log(`Max iterations hit: ${this.iterations}`)\n        return null\n        // throw new Error('Unsolvable. Iteration limit hit.');\n      }\n      \n      if (orig_grid[i] !== \"\") {\n        i++;\n      }\n      \n      if (grid[i] === \"\") {\n        grid[i] = 1;\n      }\n\n      if (grid[i] > 9) {\n        grid[i] = \"\";\n        i--;\n        while (i >= 0 && orig_grid[i] !== \"\") {\n          i--;\n        }\n        if (i<0) { // unsolvable\n          // console.log(grid);\n          console.log(`Unsolvable. Iterations: ${this.iterations}`)\n          return null\n        } \n        grid[i]++;\n      }\n\n      if (constraints_met.element(grid, i) && grid[i] <= 9) {\n        i++;\n        while (i < 81 && orig_grid[i] !== \"\") {\n          i++;\n        }\n      } else {\n        grid[i]++;\n      }\n    }\n\n    console.log(`Iterations for solution: ${this.iterations}`)\n    return grid;\n  }\n\n  \n  nextCoordinate(row, col) {\n    if (col < 8) {\n      col++;\n    } else {\n      row++;\n      col = 0;\n    }\n    return [row, col];\n  }\n\n  prevCoordinate(row, col) {\n    if (col > 0) {\n      col--;\n    } else {\n      row--;\n      col = 8;\n    }\n    return [row, col];\n  }\n\n  // update grid //copied from solver.js. Needs consolidation later.\n  updateGrid(grid, updates) {\n    for (let itemIndex in updates) {\n      let rowIndex = Math.floor(itemIndex / 9);\n      let colIndex = itemIndex - rowIndex * 9;\n      console.log(`Changing ${rowIndex}:${colIndex},(${itemIndex})   :  ${updates[itemIndex]}`)\n      grid[rowIndex][colIndex] = updates[itemIndex];\n    }\n    return grid;\n  }\n}\n\nexport default BruteSolve"]},"metadata":{},"sourceType":"module"}