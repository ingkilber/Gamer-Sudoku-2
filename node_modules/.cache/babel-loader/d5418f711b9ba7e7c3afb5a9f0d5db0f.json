{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\alons\\\\OneDrive\\\\Documentos\\\\Todos los proyectos descargados\\\\react-sudoku-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { get_row, get_col, get_square, range } from '../common/helper_functions';\nexport function CalculateUniqueOptions(options) {\n  var uniqueOptions = [];\n\n  var _iterator = _createForOfIteratorHelper(range(0, 9)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var rowIndex = _step.value;\n      var rowOptions_perRow = get_row(options, rowIndex); // whole row\n\n      var _iterator2 = _createForOfIteratorHelper(range(0, 9)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var colIndex = _step2.value;\n          var index = rowIndex * 9 + colIndex;\n\n          if (options[index] !== []) {\n            var sqrIndex = Math.floor(rowIndex / 3) * 3 + Math.floor(colIndex / 3);\n\n            var rowOptions = _toConsumableArray(rowOptions_perRow); // copy of whole row\n\n\n            var colOptions = get_col(options, colIndex); // whole column\n\n            var sqrOptions = get_square(options, sqrIndex); // whole square\n\n            rowOptions.splice(colIndex, 1);\n            colOptions.splice(rowIndex, 1);\n            sqrOptions.splice(sqrIndex, 1);\n            uniqueOptions[index] = checkUniqueOptions(rowOptions, options[index]) //needs to be array of uniqueOptions\n            .concat(checkUniqueOptions(colOptions, options[index])).concat(checkUniqueOptions(sqrOptions, options[index])).splice(0, 1);\n          } else {\n            uniqueOptions[index] = [];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  ;\n  return uniqueOptions;\n}\n\nfunction checkUniqueOptions(concatGrps, thisOptions) {\n  var foundOptions = [];\n  var concatAllGrps = concatGrps.reduce(function (prev, curr) {\n    return prev.concat(curr);\n  });\n\n  var _iterator3 = _createForOfIteratorHelper(thisOptions),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var option = _step3.value;\n\n      if (!concatAllGrps.includes(option)) {\n        foundOptions.push(option);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return foundOptions;\n}\n\nexport default CalculateUniqueOptions;","map":{"version":3,"sources":["C:/Users/alons/OneDrive/Documentos/Todos los proyectos descargados/react-sudoku-master/src/components/CalculateUniqueOptions.js"],"names":["get_row","get_col","get_square","range","CalculateUniqueOptions","options","uniqueOptions","rowIndex","rowOptions_perRow","colIndex","index","sqrIndex","Math","floor","rowOptions","colOptions","sqrOptions","splice","checkUniqueOptions","concat","concatGrps","thisOptions","foundOptions","concatAllGrps","reduce","prev","curr","option","includes","push"],"mappings":";;AAAA,SAASA,OAAT,EAAkBC,OAAlB,EAA2BC,UAA3B,EAAuCC,KAAvC,QAAoD,4BAApD;AAEA,OAAO,SAASC,sBAAT,CAAgCC,OAAhC,EAAyC;AAC9C,MAAMC,aAAa,GAAG,EAAtB;;AAD8C,6CAGzBH,KAAK,CAAC,CAAD,EAAG,CAAH,CAHoB;AAAA;;AAAA;AAG9C,wDAAiC;AAAA,UAAxBI,QAAwB;AAC/B,UAAIC,iBAAiB,GAAGR,OAAO,CAACK,OAAD,EAAUE,QAAV,CAA/B,CAD+B,CACqB;;AADrB,kDAGVJ,KAAK,CAAC,CAAD,EAAI,CAAJ,CAHK;AAAA;;AAAA;AAG/B,+DAAkC;AAAA,cAAzBM,QAAyB;AAChC,cAAIC,KAAK,GAAGH,QAAQ,GAAC,CAAT,GAAaE,QAAzB;;AAEA,cAAIJ,OAAO,CAACK,KAAD,CAAP,KAAmB,EAAvB,EAA2B;AACzB,gBAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWN,QAAQ,GAAG,CAAtB,IAA2B,CAA3B,GAA+BK,IAAI,CAACC,KAAL,CAAWJ,QAAQ,GAAG,CAAtB,CAA9C;;AAEA,gBAAIK,UAAU,sBAAON,iBAAP,CAAd,CAHyB,CAGgB;;;AACzC,gBAAIO,UAAU,GAAGd,OAAO,CAACI,OAAD,EAAUI,QAAV,CAAxB,CAJyB,CAIoB;;AAC7C,gBAAIO,UAAU,GAAGd,UAAU,CAACG,OAAD,EAASM,QAAT,CAA3B,CALyB,CAKsB;;AAE/CG,YAAAA,UAAU,CAACG,MAAX,CAAkBR,QAAlB,EAA4B,CAA5B;AACAM,YAAAA,UAAU,CAACE,MAAX,CAAkBV,QAAlB,EAA4B,CAA5B;AACAS,YAAAA,UAAU,CAACC,MAAX,CAAkBN,QAAlB,EAA4B,CAA5B;AAEAL,YAAAA,aAAa,CAACI,KAAD,CAAb,GACEQ,kBAAkB,CAACJ,UAAD,EAAaT,OAAO,CAACK,KAAD,CAApB,CAAlB,CAA+C;AAA/C,aACGS,MADH,CACUD,kBAAkB,CAACH,UAAD,EAAaV,OAAO,CAACK,KAAD,CAApB,CAD5B,EAEGS,MAFH,CAEUD,kBAAkB,CAACF,UAAD,EAAaX,OAAO,CAACK,KAAD,CAApB,CAF5B,EAE0DO,MAF1D,CAEiE,CAFjE,EAEoE,CAFpE,CADF;AAMD,WAjBD,MAkBK;AACHX,YAAAA,aAAa,CAACI,KAAD,CAAb,GAAuB,EAAvB;AACD;AACF;AA3B8B;AAAA;AAAA;AAAA;AAAA;AA4BhC;AA/B6C;AAAA;AAAA;AAAA;AAAA;;AA+B7C;AACD,SAAOJ,aAAP;AACD;;AAED,SAASY,kBAAT,CAA4BE,UAA5B,EAAwCC,WAAxC,EAAqD;AACnD,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,aAAa,GAAGH,UAAU,CAACI,MAAX,CAAkB,UAACC,IAAD,EAAOC,IAAP;AAAA,WAAgBD,IAAI,CAACN,MAAL,CAAYO,IAAZ,CAAhB;AAAA,GAAlB,CAApB;;AAFmD,8CAIhCL,WAJgC;AAAA;;AAAA;AAInD,2DAAgC;AAAA,UAAvBM,MAAuB;;AAC9B,UAAI,CAACJ,aAAa,CAACK,QAAd,CAAuBD,MAAvB,CAAL,EAAqC;AACnCL,QAAAA,YAAY,CAACO,IAAb,CAAkBF,MAAlB;AACD;AACF;AARkD;AAAA;AAAA;AAAA;AAAA;;AASnD,SAAOL,YAAP;AACD;;AAED,eAAelB,sBAAf","sourcesContent":["import { get_row, get_col, get_square, range } from '../common/helper_functions';\n\nexport function CalculateUniqueOptions(options) {\n  const uniqueOptions = [];\n\n  for (let rowIndex of range(0,9)) {\n    let rowOptions_perRow = get_row(options, rowIndex); // whole row\n\n    for (let colIndex of range(0, 9)) {\n      let index = rowIndex*9 + colIndex;\n\n      if (options[index] !== []) {\n        let sqrIndex = Math.floor(rowIndex / 3) * 3 + Math.floor(colIndex / 3)\n        \n        let rowOptions = [...rowOptions_perRow]; // copy of whole row\n        let colOptions = get_col(options, colIndex); // whole column\n        let sqrOptions = get_square(options,sqrIndex); // whole square\n\n        rowOptions.splice(colIndex, 1);\n        colOptions.splice(rowIndex, 1);\n        sqrOptions.splice(sqrIndex, 1);\n\n        uniqueOptions[index] = (\n          checkUniqueOptions(rowOptions, options[index]) //needs to be array of uniqueOptions\n            .concat(checkUniqueOptions(colOptions, options[index]))\n            .concat(checkUniqueOptions(sqrOptions, options[index])).splice(0, 1)\n        );\n\n      }\n      else {\n        uniqueOptions[index] = [];\n      }\n    }\n  };\n  return uniqueOptions;\n}\n\nfunction checkUniqueOptions(concatGrps, thisOptions) {\n  let foundOptions = [];\n  let concatAllGrps = concatGrps.reduce((prev, curr) => prev.concat(curr));\n\n  for (let option of thisOptions) {\n    if (!concatAllGrps.includes(option)) {\n      foundOptions.push(option);\n    }\n  }\n  return foundOptions;\n}\n\nexport default CalculateUniqueOptions;\n"]},"metadata":{},"sourceType":"module"}